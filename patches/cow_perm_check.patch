So far the permission was checked, when it was too late already - when the file was 
copied with cow already. Introduce permission checks for cow functions.

Patch author: bernd.schubert@fastmail.fm

diff --git a/src/findbranch.c b/src/findbranch.c
--- a/src/findbranch.c
+++ b/src/findbranch.c
@@ -49,6 +49,7 @@
 #include "findbranch.h"
 #include "string.h"
 #include "debug.h"
+#include "permission.h"
 
 /**
  *  Find a branch that has "path". Return the branch number.
@@ -104,13 +105,17 @@ int find_rorw_branch(const char *path) {
  * Find a writable branch. If file does not exist, we check for
  * the parent directory.
  */
-int find_rw_branch_cutlast(const char *path) {
+int find_rw_branch_cutlast(const char *path, perm_check_t *perm_check) {
 	DBG_IN();
 
-	int branch = find_rw_branch_cow(path);
+	int branch = find_rw_branch_cow(path, perm_check);
 
-	if (branch >= 0 || (branch < 0 && errno != ENOENT))
-		return branch;
+	if (branch >= 0 || (branch < 0 && errno != ENOENT)) {
+		if (modify_permission(path, perm_check, branch) == false) 
+			return -1;
+		else
+			return branch;
+	}
 
 	DBG("Check for parent directory\n");
 
@@ -120,7 +125,17 @@ int find_rw_branch_cutlast(const char *p
 	char *dname = u_dirname(path);
 	branch = find_rorw_branch(dname);
 
-	if (branch < 0 || uopt.branches[branch].rw) goto out;
+	if (branch < 0) goto out;
+
+	// check if we are at all allowed to write to this path, we also need 
+	// to check for this before we are going to copy this path to a rw branch
+	if (modify_permission(path, perm_check, branch) == false) {
+		branch = -1;
+		goto out;
+	}
+
+	if (uopt.branches[branch].rw)
+		goto out; // the branch is writable no need for cow
 
 	if (!uopt.cow_enabled) {
 		// So path exists, but is not writable.
@@ -154,13 +169,16 @@ out:
  *       It will definitely fail, when a ro-branch is on top of a rw-branch
  *       and a directory is to be copied from ro- to rw-branch.
  */
-int find_rw_branch_cow(const char *path) {
+int find_rw_branch_cow(const char *path, perm_check_t *perm_check) {
 	DBG_IN();
 
 	int branch_rorw = find_rorw_branch(path);
 
 	// not found anywhere
 	if (branch_rorw < 0) return -1;
+
+	if (modify_permission(path, perm_check, branch_rorw) == false) 
+		return -1; // no write permission
 
 	// the found branch is writable, good!
 	if (uopt.branches[branch_rorw].rw) return branch_rorw;
diff --git a/src/findbranch.h b/src/findbranch.h
--- a/src/findbranch.h
+++ b/src/findbranch.h
@@ -12,9 +12,23 @@ typedef enum searchflag {
 	RWONLY
 } searchflag_t;
 
+
+typedef struct perm_check {
+	enum checktype {
+		NO_CHECK = 0,
+		WRITE,
+		PARENT_WRITE,
+		CHOWN,
+	} checktype; // permission check type
+
+	uid_t uid;		// for chown permission
+	gid_t gid;		// for chmod permission
+} perm_check_t;
+
+
 int find_rorw_branch(const char *path);
 int find_lowest_rw_branch(int branch_ro);
-int find_rw_branch_cutlast(const char *path);
-int find_rw_branch_cow(const char *path);
+int find_rw_branch_cutlast(const char *path, perm_check_t *perm_check);
+int find_rw_branch_cow(const char *path, perm_check_t *perm_check);
 
 #endif
diff --git a/src/permission.c b/src/permission.c
--- a/src/permission.c
+++ b/src/permission.c
@@ -160,3 +160,38 @@ int chown_permission(const char *path, u
 	return -EPERM;
 }
 
+
+/**
+ * Check if the user is allowed to modify the file
+ */
+bool modify_permission(const char *path, struct perm_check *perm_check, int branch)
+{
+	char p[PATHLEN_MAX];
+
+	if (BUILD_PATH(p, uopt.branches[branch].path, path)) return false;
+
+	int res = 0;
+	switch (perm_check->checktype) {
+		case NO_CHECK:
+			break;
+		case WRITE:
+			res = generic_permission(p, W_OK);
+			break;
+		case CHOWN:
+			res = chown_permission(p, perm_check->uid, perm_check->gid);
+			break;
+		case PARENT_WRITE:
+			res = parent_write_ok(p);
+			break;
+		default:
+			usyslog(LOG_WARNING, "%s: unknown check type: %d\n",
+			       perm_check->checktype);
+	}
+	if (res) {
+		errno = EPERM;
+		return false;
+	}
+
+	return true;
+}
+
diff --git a/src/permission.h b/src/permission.h
--- a/src/permission.h
+++ b/src/permission.h
@@ -7,8 +7,11 @@
 #ifndef ACCESS_H
 #define ACCESS_H
 
+#include "findbranch.h"
+
 int generic_permission (const char *path, int mask);
 int parent_write_ok (const char *path);
 int chown_permission(const char *path, uid_t uid, gid_t gid);
+bool modify_permission(const char *path, struct perm_check *perm_check, int branch);
 
 #endif
diff --git a/src/unionfs.c b/src/unionfs.c
--- a/src/unionfs.c
+++ b/src/unionfs.c
@@ -71,16 +71,14 @@ static int unionfs_chmod(const char *pat
 static int unionfs_chmod(const char *path, mode_t mode) {
 	DBG_IN();
 
-	int i = find_rw_branch_cow(path);
+	perm_check_t perm_check = {.checktype = WRITE};
+	int i = find_rw_branch_cow(path, &perm_check);
 	if (i == -1) return -errno;
 
 	char p[PATHLEN_MAX];
 	snprintf(p, PATHLEN_MAX, "%s%s", uopt.branches[i].path, path);
 
-	int res = generic_permission(p, W_OK);
-	if (res) return res;
-
-	res = chmod(p, mode);
+	int res = chmod(p, mode);
 
 	if (res == -1) return -errno;
 
@@ -90,16 +88,14 @@ static int unionfs_chown(const char *pat
 static int unionfs_chown(const char *path, uid_t uid, gid_t gid) {
 	DBG_IN();
 
-	int i = find_rw_branch_cow(path);
+	perm_check_t perm_check = {.checktype = CHOWN, .uid = uid, .gid = gid};
+	int i = find_rw_branch_cow(path, &perm_check);
 	if (i == -1) return -errno;
 
 	char p[PATHLEN_MAX];
 	snprintf(p, PATHLEN_MAX, "%s%s", uopt.branches[i].path, path);
 
-	int res = chown_permission(p, uid, gid);
-	if (res) return res;
-
-	res = lchown(p, uid, gid);
+	int res = lchown(p, uid, gid);
 	if (res == -1) return -errno;
 
 	return 0;
@@ -112,7 +108,8 @@ static int unionfs_create(const char *pa
 static int unionfs_create(const char *path, mode_t mode, struct fuse_file_info *fi) {
 	DBG_IN();
 
-	int i = find_rw_branch_cutlast(path);
+	perm_check_t perm_check = {.checktype = PARENT_WRITE};
+	int i = find_rw_branch_cutlast(path, &perm_check);
 	if (i == -1) return -errno;
 
 	char p[PATHLEN_MAX];
@@ -226,22 +223,15 @@ static int unionfs_link(const char *from
 	DBG_IN();
 	
 	// hardlinks do not work across different filesystems so we need a copy of from first
-	int i = find_rw_branch_cow(from);
+	perm_check_t perm_check = {.checktype = PARENT_WRITE};
+	int i = find_rw_branch_cow(from, &perm_check);
 	if (i == -1) return -errno;
 
 	char f[PATHLEN_MAX], t[PATHLEN_MAX];
 	snprintf(f, PATHLEN_MAX, "%s%s", uopt.branches[i].path, from);
 	snprintf(t, PATHLEN_MAX, "%s%s", uopt.branches[i].path, to);
 
-	int res = parent_write_ok(t);
-	if (res) {
-		// TODO: Actually we shouldn't initiate the previous COW at all if we
-		//      don't have write permission. Or at least we need to delete the
-		//	file again.
-		 return res;
-	}
-
-	res = link(f, t);
+	int res = link(f, t);
 
 	set_owner(t); // no error check, since creating the file succeeded
 
@@ -260,16 +250,15 @@ static int unionfs_mkdir(const char *pat
 static int unionfs_mkdir(const char *path, mode_t mode) {
 	DBG_IN();
 
-	int i = find_rw_branch_cutlast(path);
+	// hardlinks do not work across different filesystems so we need a copy of from first
+	perm_check_t perm_check = {.checktype = PARENT_WRITE};
+	int i = find_rw_branch_cutlast(path, &perm_check);
 	if (i == -1) return -errno;
-
-	int res = parent_write_ok(path);
-	if (res)  return res;
 
 	char p[PATHLEN_MAX];
 	snprintf(p, PATHLEN_MAX, "%s%s", uopt.branches[i].path, path);
 
-	res = mkdir(p, mode);
+	int res = mkdir(p, mode);
 
 	if (res == -1) return -errno;
 
@@ -281,16 +270,14 @@ static int unionfs_mknod(const char *pat
 static int unionfs_mknod(const char *path, mode_t mode, dev_t rdev) {
 	DBG_IN();
 
-	int i = find_rw_branch_cutlast(path);
+	perm_check_t perm_check = {.checktype = PARENT_WRITE};
+	int i = find_rw_branch_cutlast(path, &perm_check);
 	if (i == -1) return -errno;
 
 	char p[PATHLEN_MAX];
 	snprintf(p, PATHLEN_MAX, "%s%s", uopt.branches[i].path, path);
 
-	int res = parent_write_ok(p);
-	if (res)  return res;
-
-	res = -1;
+	int res = -1;
 	if ((mode & S_IFMT) == S_IFREG) {
 		// under FreeBSD, only the super-user can create ordinary files using mknod
 		// Actually this workaround should not be required any more
@@ -329,7 +316,8 @@ static int unionfs_open(const char *path
 
 	int i;
 	if (fi->flags & (O_WRONLY | O_RDWR)) {
-		i = find_rw_branch_cutlast(path);
+		perm_check_t perm_check = {.checktype = PARENT_WRITE};
+		i = find_rw_branch_cutlast(path, &perm_check);
 	} else {
 		i = find_rorw_branch(path);
 	}
@@ -444,14 +432,15 @@ static int unionfs_rename(const char *fr
 	
 	bool is_dir = false; // is 'from' a file or directory
 
-	int j = find_rw_branch_cutlast(to);
+	perm_check_t perm_check = {.checktype = PARENT_WRITE};
+	int j = find_rw_branch_cutlast(to, &perm_check);
 	if (j == -1) return -errno;
 
 	int i = find_rorw_branch(from);
 	if (i == -1) return -errno;
 
 	if (!uopt.branches[i].rw) {
-		i = find_rw_branch_cow(from);
+		i = find_rw_branch_cow(from, &perm_check);
 		if (i == -1) return -errno;
 	}
 
@@ -575,7 +564,8 @@ static int unionfs_symlink(const char *f
 static int unionfs_symlink(const char *from, const char *to) {
 	DBG_IN();
 
-	int i = find_rw_branch_cutlast(to);
+	perm_check_t perm_check = {.checktype = PARENT_WRITE};
+	int i = find_rw_branch_cutlast(to, &perm_check);
 	if (i == -1) return -errno;
 
 	char t[PATHLEN_MAX];
@@ -596,7 +586,8 @@ static int unionfs_truncate(const char *
 static int unionfs_truncate(const char *path, off_t size) {
 	DBG_IN();
 
-	int i = find_rw_branch_cow(path);
+	perm_check_t perm_check = {.checktype = PARENT_WRITE};
+	int i = find_rw_branch_cow(path, &perm_check);
 	if (i == -1) return -errno;
 
 	char p[PATHLEN_MAX];
@@ -621,7 +612,8 @@ static int unionfs_utime(const char *pat
 
 	if (uopt.stats_enabled && strcmp(path, STATS_FILENAME) == 0) return 0;
 
-	int i = find_rw_branch_cow(path);
+	perm_check_t perm_check = {.checktype = PARENT_WRITE};
+	int i = find_rw_branch_cow(path, &perm_check);
 	if (i == -1) return -errno;
 
 	char p[PATHLEN_MAX];
